#include "dflow_calc.h"

#include <stdio.h>
#include <iostream>
#include <iostream>
#include <sstream>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <cstdlib>

using namespace std;

class Signal_Instruction {
    public:
    unsigned latency_Instruction; //will hold the time that take to the instruction to operate
    unsigned latency_total_until_here; //hold the total latency without the current command 
    int dependency_Operand_A; //Will hold the number of an instruction on which it depends
    int dependency_Operand_B; //Will hold the number of an instruction on which it depends

    Signal_Instruction() : dependency_Operand_A(-1), dependency_Operand_B(-1), latency_total_until_here(0) {}
};

class Ctx {
    public:
        Signal_Instruction *Instruction;
        int Max_latency;
        int num_of_instruction;
        Ctx(): Max_latency(0){}
};


#define CTX_EXPAND(ptr) Signal_Instruction *&Instruction = ((Ctx*)ptr)->Instruction;\
                        int &Max_latency = ((Ctx*)ptr)->Max_latency;\
                        int &num_of_instruction = ((Ctx*)ptr)->num_of_instruction

ProgCtx analyzeProg(const unsigned int opsLatency[], const InstInfo progTrace[], unsigned int numOfInsts) {
    Ctx *ptr = new Ctx();
    CTX_EXPAND(ptr);

    Instruction = new Signal_Instruction[numOfInsts]();//initialize an array that contain a data for each instruction
    num_of_instruction = numOfInsts;
    for(int i=0; i < (int) numOfInsts; i++){
        Instruction[i].latency_Instruction=opsLatency[progTrace[i].opcode];//insert the latency to the relevant instruction

        //checking for dependency for src1Idx
        // removed since always legal(?): if (Instruction[i].dependency_Operand_A >= 0)
            for(int j=i-1; j>=0; j--) {
               if(progTrace[i].src1Idx == progTrace[j].dstIdx) {//we have RAW!
                   Instruction[i].dependency_Operand_A = j;
                   Instruction[i].latency_total_until_here = Instruction[j].latency_total_until_here + Instruction[j].latency_Instruction;//calculate the time of dependency
                   break;
               }
            }

        //checking for dependency for src2Idx
        // if (Instruction[i].dependency_Operand_B >= 0)
            for(int j=i-1; j>=0; j--){
               if(progTrace[i].src2Idx == progTrace[j].dstIdx) {//we have RAW!
                   Instruction[i].dependency_Operand_B=j;
                   // take the max between the 2 latencies:
                   int temp = Instruction[j].latency_total_until_here + Instruction[j].latency_Instruction;
                   if(temp > Instruction[i].latency_total_until_here){
                       Instruction[i].latency_total_until_here=temp;
                   }
                   break;
               }
            }

        // update maximal latency
        int temp = Instruction[i].latency_total_until_here + Instruction[i].latency_Instruction;
        if (temp > Max_latency){
            Max_latency = temp;
        }
    }
    
    return ptr;
}


void freeProgCtx(ProgCtx ctx) {
    delete[] ((Ctx*)ctx)->Instruction;
    delete (Ctx*) ctx;
}


int getInstDepth(ProgCtx ctx, unsigned int theInst) {
    CTX_EXPAND(ctx);
    if ((theInst>=0)&&(theInst<=(int)num_of_instruction)){
        return Instruction[theInst].latency_total_until_here;
    }
    return -1;
}

int getInstDeps(ProgCtx ctx, unsigned int theInst, int *src1DepInst, int *src2DepInst) {
    CTX_EXPAND(ctx);
    if ((theInst >= 0) && (theInst <= (int)num_of_instruction)){
        *src1DepInst = Instruction[theInst].dependency_Operand_A;
        *src2DepInst = Instruction[theInst].dependency_Operand_B;
        return 0;
    }
    return -1;
}

int getProgDepth(ProgCtx ctx) {
    CTX_EXPAND(ctx);
    return Max_latency;
}



